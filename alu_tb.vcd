$date
	Sat Dec 20 16:11:30 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module alu_tb $end
$var wire 1 ! C $end
$var wire 1 " N $end
$var wire 16 # R [15:0] $end
$var wire 1 $ V $end
$var wire 1 % Z $end
$var reg 16 & A [15:0] $end
$var reg 16 ' B [15:0] $end
$var reg 3 ( fun [2:0] $end
$scope module dut $end
$var wire 16 ) A [15:0] $end
$var wire 17 * A_ext [16:0] $end
$var wire 16 + B [15:0] $end
$var wire 17 , B_ext [16:0] $end
$var wire 1 ! C $end
$var wire 1 - C_add $end
$var wire 1 . C_sub $end
$var wire 1 " N $end
$var wire 16 / R_AND [15:0] $end
$var wire 16 0 R_ASR [15:0] $end
$var wire 16 1 R_LSL [15:0] $end
$var wire 16 2 R_LSR [15:0] $end
$var wire 16 3 R_NOR [15:0] $end
$var wire 16 4 R_OR [15:0] $end
$var wire 17 5 R_add [16:0] $end
$var wire 17 6 R_sub [16:0] $end
$var wire 1 $ V $end
$var wire 1 7 V_add $end
$var wire 1 8 V_sub $end
$var wire 1 % Z $end
$var wire 3 9 fun [2:0] $end
$var reg 16 : R [15:0] $end
$upscope $end
$scope task do_test $end
$var reg 16 ; a [15:0] $end
$var reg 16 < b [15:0] $end
$var reg 1 = expC $end
$var reg 1 > expN $end
$var reg 16 ? expR [15:0] $end
$var reg 17 @ expR_ext [16:0] $end
$var reg 1 A expV $end
$var reg 1 B expZ $end
$var reg 3 C op [2:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b0 C
xB
xA
bx @
bx ?
x>
x=
b1 <
b1 ;
b10 :
b0 9
08
07
b0 6
b10 5
b1 4
b1111111111111110 3
b0 2
b10 1
b0 0
b1 /
0.
0-
b1 ,
b1 +
b1 *
b1 )
b0 (
b1 '
b1 &
0%
0$
b10 #
0"
0!
$end
#1
1!
b0 3
1-
b1111111111111111 4
b0 :
1%
b0 #
b1111111111111111 &
b1111111111111111 )
b10000000000000000 5
b1111111111111110 6
b1111111111111111 *
b1111111111111110 1
b111111111111111 2
b1111111111111111 0
b1111111111111111 ;
0A
0=
0B
0>
b10 ?
b10 @
#2
1$
17
0!
b1000000000000000 3
0-
1"
b111111111111111 4
b1000000000000000 :
0%
b1000000000000000 #
b111111111111111 &
b111111111111111 )
b1000000000000000 5
b111111111111110 6
b111111111111111 *
b11111111111111 2
b11111111111111 0
b111111111111111 ;
1=
1B
b0 ?
b10000000000000000 @
#3
0!
0$
b1111111111111000 3
0.
07
b11 /
b111 4
b1111111111111100 :
0%
b1111111111111100 #
b1 (
b1 9
b111 '
b111 +
b111 ,
b11 &
b11 )
b1010 5
b11111111111111100 6
b11 *
b110000000 1
b0 2
b0 0
b1 C
b111 <
b11 ;
1A
0=
0B
1>
b1000000000000000 ?
b1000000000000000 @
#4
b1111111111111110 3
b0 /
b1 4
b1111111111111111 :
0%
b1111111111111111 #
b1 '
b1 +
b1 ,
b0 &
b0 )
b1 5
b11111111111111111 6
b0 *
b0 1
b1 <
b0 ;
0A
b1111111111111100 ?
b11111111111111100 @
#5
1$
1!
18
1.
b0 3
0"
b1111111111111111 4
b1 :
0%
b1 #
b111111111111111 '
b111111111111111 +
b111111111111111 ,
b1000000000000000 &
b1000000000000000 )
b1111111111111111 5
b1 6
b1000000000000000 *
b1 2
b1111111111111111 0
b111111111111111 <
b1000000000000000 ;
b1111111111111111 ?
b11111111111111111 @
#6
0!
0$
b1111000000000000 3
0.
08
b1111 /
b111111111111 4
b1111 :
0%
b1111 #
b10 (
b10 9
b111100001111 '
b111100001111 +
b111100001111 ,
b11111111 &
b11111111 )
b1000000001110 5
b11111000111110000 6
b11111111 *
b1000000000000000 1
b0 2
b0 0
b10 C
b111100001111 <
b11111111 ;
1A
1=
0>
b1 ?
b1 @
#7
b111111111111 :
0%
b111111111111 #
b11 (
b11 9
b11 C
0A
0=
b1111 ?
b1111 @
#8
1"
b1111000000000000 :
0%
b1111000000000000 #
b100 (
b100 9
b100 C
b111111111111 ?
b111111111111 @
#9
0"
b1111111111111010 3
b10000 1
b0 /
b101 4
b10000 :
0%
b10000 #
b101 (
b101 9
b100 '
b100 +
b100 ,
b1 &
b1 )
b101 5
b11111111111111101 6
b1 *
b101 C
b100 <
b1 ;
1>
b1111000000000000 ?
b1111000000000000 @
#10
b111111111111110 3
b1000000000000001 4
b100000000000000 :
0%
b100000000000000 #
b110 (
b110 9
b1 '
b1 +
b1 ,
b1000000000000000 &
b1000000000000000 )
b1000000000000001 5
b111111111111111 6
b1000000000000000 *
b0 1
b100000000000000 2
b1100000000000000 0
b110 C
b1 <
b1000000000000000 ;
0>
b10000 ?
b10000 @
#11
1"
b1100000000000000 :
0%
b1100000000000000 #
b111 (
b111 9
b111 C
b100000000000000 ?
b100000000000000 @
#12
1>
b1100000000000000 ?
b1100000000000000 @
